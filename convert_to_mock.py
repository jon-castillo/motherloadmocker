#################################################
#          convert_to_mock.py                   #
#################################################
# Script to filter methods from class files     #
# --------------------------------------------- #
# Author: Jonathan Castillo                     #
# Date:   June 17, 2016                         #
#################################################

import sys
import os
import re
import collections
import datetime
import myexpressions

def main():
    print myexpressions.str_regexpattern_method_cppmethod
    print ''
    print 'specifierfront: '+myexpressions.str_debug_specifierfront
    print 'returntype:     '+myexpressions.str_debug_returntype
    print 'methodname:     '+myexpressions.str_debug_methodname
    print 'paramlist:      '+myexpressions.str_debug_paramlist
    print 'initializerlist:'+myexpressions.str_debug_initlist
    print 'specifierback:  '+myexpressions.str_debug_specifierback
    print ''

    print ''
    if len(sys.argv) is not 2:
        print "Please provide source header to process."
        print "example:"
        print (sys.argv)[0] + " c:\sources\source.hpp"
        return
    else:
        filename = (sys.argv)[1]
        if not os.path.isfile(filename):
            print "not a file!"
            return
        processHeader(filename)
        return


def printHeader(filename, basename):
    print "/****************************************************************************************************/"
    print ("/* " + basename).ljust(100) + "*/"
    print "/****************************************************************************************************/"
    print ("/* This file was generated by convert_to_mock.py").ljust(100) +"*/"
    print ("/* Mocked from: " + filename).ljust(100) + "*/" 
    print ("/* author:    jonathan.castillo@continental-corporation.com").ljust(100)+"*/"
    print ("/* generated: " + datetime.datetime.now().strftime('%d %b %Y, %H:%M')).ljust(100) +"*/"
    print "/****************************************************************************************************/"

def processHeader(filename):
    fread = open(filename,'r')

    basename = os.path.basename(filename)
    splitext = os.path.splitext(basename)
    rootname = splitext[0].upper()
    preprocessor_directive_name = "__MOCKED_"+rootname+"__"

    printHeader(filename, basename)
    print "#ifndef " + preprocessor_directive_name
    print "#define " + preprocessor_directive_name
    print ""

    BOOL_INSIDE_A_CLASS = False;

    for line in fread:
        if BOOL_INSIDE_A_CLASS is False:
            SeekInclude(line);
            BOOL_INSIDE_A_CLASS = SeekClassDefinition(line);
            BOOL_INSIDE_A_STRUCT = SeekStructDefinition(line);
            BOOL_INSIDE_A_NAMESPACE = SeekNamespaceDefinition(line);
            BOOL_CLASS_FORWARD_DECL = SeekClassForwardDeclaration(line);

        else:
            BOOL_METHOD_FOUND = SeekMethod(line)

            if BOOL_METHOD_FOUND is False:
                BOOL_INSIDE_A_CLASS = not CheckEndClass(line)

    print "#endif "

    return


def SeekClassForwardDeclaration(line):
    pattern = re.compile(r'^\s*(class|struct)\s+([\w]+)\s*;\s*$')
    match = pattern.match( line )
    output = ""
    if match is not None:
        output += "struct "
        STR_CLASSTYPE = match.group(1)
        output += STR_CLASSTYPE;
        if match.group(2) is not None:
            STR_CLASSNAME = match.group(2)
            output += " "
            output += STR_CLASSNAME;
        output += ";"
        print output
        return True;
    else: 
        return False;



def SeekStructDefinition(line):
    pattern = re.compile(r'^\s*(?:struct)\s+([\w]+)\s*(?::){0,1}((?:\s*(?:(?:public|protected|private)\s+){0,1}[\w:]??(?:\s*,){0,1})+)\s*(?:{){0,1}$')
    match = pattern.match( line )
    output = ""
    if match is not None:
        output += "struct "
        STR_CLASSNAME = match.group(1)
        output += STR_CLASSNAME;
        if match.group(2) is not None:
            STR_BASECLAUSE = match.group(2)
            print "bc is::"
            print STR_BASECLAUSE 
            output += ":"
            output += STR_BASECLAUSE;
        output += " {"
        print output
        return True;
    else: 
        return False;



def SeekInclude(line):
    pattern = re.compile(r'^\s*#include\s*(\"|<)(.+)(\"|>)\s*$')
    match = pattern.match( line )

    if match is not None:
        STR_INCLUDEDFILE = match.group(2)
        STR_OPENBRACKET = match.group(1)
        STR_CLOSEBRACKET = match.group(3)
        print "#include" + " " + STR_OPENBRACKET + STR_INCLUDEDFILE + STR_CLOSEBRACKET
        return True;
    else:
        return False;

def SeekNamespaceDefinition( line ):
    pattern = re.compile(r'^\s*(?:namespace)\s+([\w:]+)\s*({){0,1}\s*$')
    match = pattern.match( line )
    output = ""
    if match is not None:
        output += "namespace "
        STR_NAMESPACENAME = match.group(1)
        output += STR_NAMESPACENAME
        output += "{"
        print output
        return True;
    else:
        return False;



def SeekClassDefinition(line):
#    pattern = re.compile(r'^\s*class\s*(\w*)')
    pattern = re.compile(r'^\s*(?:class)\s+([\w]+)\s*(?::){0,1}((?:\s*(?:(?:public|protected|private)\s+){0,1}[\w:]??(?:\s*,){0,1})+)\s*(?:{){0,1}$')
    match = pattern.match( line )
    output = ""
    if match is not None:
        output += "class "
        STR_CLASSNAME = match.group(1)
        output += STR_CLASSNAME;
        if match.group(2) is not None:
            STR_BASECLAUSE = match.group(2)
            output += ":"
            output += STR_BASECLAUSE;
        output += " {"
        print output
        return True;
    else: 
        return False;

def SeekMethod(line):
    # pattern = re.compile(r'^\s*(virtual|explicit|override)??\s+([\w:]*?)\s*([*&])?\s*([\w:\~=\[\]<>!\*\-\+]*)\s*\(([a-zA-Z0-9,  _\s&*:]*?)\)\s*:?\s*([\w\(\),]*)\s*({|;|\Z)')
    pattern =re.compile(r""+myexpressions.str_regexpattern_method_cppmethod)
    match = pattern.match( line )
    if match is not None:
        if match.group(1) is not None:
            STR_FUNCTIONSPECIFIER_FRONT = match.group(1)
        else:
            STR_FUNCTIONSPECIFIER_FRONT = ''
        if match.group(2) is not None:
            STR_RETURNTYPE = match.group(2)
        else:
            STR_RETURNTYPE = ''
        if match.group(3) is not None:
            STR_METHODNAME = match.group(3)
        if match.group(4) is not None:
            STR_PARAMETERLIST =  match.group(4)
        if match.group(5) is not None:
            STR_INITIALIZERLIST = match.group(5)
        else:
            STR_INITIALIZERLIST = ''
        if match.group(6) is not None:
            STR_FUNCTIONSPECIFIER_BACK = match.group(6)
        else:
            STR_FUNCTIONSPECIFIER_BACK = ''

        output = "        "

        if STR_RETURNTYPE == "":
            if STR_FUNCTIONSPECIFIER_FRONT != "":
                output += STR_FUNCTIONSPECIFIER_FRONT + ' '
            output += STR_METHODNAME + '(' + STR_PARAMETERLIST + ')' 
            if STR_INITIALIZERLIST != "":
                output += ':' + STR_INITIALIZERLIST
            if STR_FUNCTIONSPECIFIER_BACK != "":
                output += ' ' + STR_FUNCTIONSPECIFIER_BACK
            output += ' { /* Stubbed to do nothing */ }'
        else:
            if 'const' in STR_FUNCTIONSPECIFIER_BACK:
                output += "MOCK_CONST_METHOD"
            else:
                output += "MOCK_METHOD"

            number_of_params = len(STR_PARAMETERLIST.split(','))
            output += str(number_of_params)
            output += '('
            output += STR_METHODNAME
            output += ','
            output += STR_RETURNTYPE
            output += '( '
            output += STR_PARAMETERLIST
            output += ') );'
        print output
        return True;
    else:
        return False

def CheckEndClass(line):
    pattern = re.compile(r'^\s*?}\s*?([\w_]*?)\s*;\s*$')

    match = pattern.match( line )

    if match is not None:
        if match.group(1) is not None:
            print '}' + match.group(1) + ';'
        else:
            print '};' 


        return True;
    else:
        return False;

if __name__ == '__main__':
    main()





