#################################################
#          convert_to_mock.py                   #
#################################################
# Script to filter methods from class files     #
# --------------------------------------------- #
# Author: Jonathan Castillo                     #
# Date:   June 17, 2016                         #
#################################################

import sys
import os
import re
import collections
import datetime
import myexpressions
import removecomments
import StringIO

writelater = ""
parentclassname = "PARENTCLASSNAME"
def main():
    print 'cppmethod:'
    print myexpressions.str_regexpattern_method_cppmethod
    print 'cppstaticmethod:'
    print myexpressions.str_regexpattern_method_cppstaticmethod
    print ''
    print 'specifierfront: '+myexpressions.str_debug_specifierfront
    print 'returntype:     '+myexpressions.str_debug_returntype
    print 'methodname:     '+myexpressions.str_debug_methodname
    print 'paramlist:      '+myexpressions.str_debug_paramlist
    print 'initializerlist:'+myexpressions.str_debug_initlist
    print 'specifierback:  '+myexpressions.str_debug_specifierback
    print 'parameter:      '+myexpressions.str_debug_parameter
    print ''

    print ''
    if len(sys.argv) is not 2:
        print "Please provide source header to process."
        print "example:"
        print (sys.argv)[0] + " c:\sources\source.hpp"
        return
    else:
        filename = (sys.argv)[1]
        if not os.path.isfile(filename):
            print "not a file!"
            return

        code_w_comments = open(filename).read()
        code_wo_comments  = removecomments.remove_comments(code_w_comments)
        processHeader(filename, code_wo_comments)
        return


def printHeader(filename, basename, fwrite):
    fwrite.write( "/****************************************************************************************************/\n" )
    fwrite.write( ("/* " + basename).ljust(100) + "*/\n" )
    fwrite.write( "/****************************************************************************************************/\n" )
    fwrite.write( ("/* This file was generated by convert_to_mock.py").ljust(100) +"*/\n" )
    fwrite.write( ("/* Mocked from: " + filename).ljust(100) + "*/\n" )
    fwrite.write( ("/* author:    jonathan.castillo@continental-corporation.com").ljust(100)+"*/\n" )
    fwrite.write( ("/* generated: " + datetime.datetime.now().strftime('%d %b %Y, %H:%M')).ljust(100) +"*/\n" )
    fwrite.write( "/****************************************************************************************************/\n" )

def processHeader(filename, code_wo_comments):
    global writelater
    #fread = open(filename,'r')
    basename = os.path.basename(filename)
    fwrite = open(".\\"+basename,'w')

    #splitext = os.path.splitext(basename)
    #rootname = splitext[0].upper()
    #preprocessor_directive_name = "__MOCKED_"+rootname+"_HPP__"
    printHeader(filename, basename ,fwrite)

    BOOL_INSIDE_A_CLASS = False;
    BOOL_INSIDE_A_STRUCT = False;

#    for line in fread:
    buf = StringIO.StringIO(code_wo_comments)

    for line in buf:
#    for line in code_wo_comments.readline():
        out = None

        if BOOL_INSIDE_A_STRUCT is True:
            BOOL_VARIABLEDECLARATION_FOUND,out = SeekVariableDeclaration(line)
            if out is not "":
                fwrite.write ( out )

            if BOOL_VARIABLEDECLARATION_FOUND is False:
                BOOL_INSIDE_A_STRUCT, out = CheckEndClass(line)
                if out is not "":
                     fwrite.write ( out )

        elif BOOL_INSIDE_A_CLASS is True:
            BOOL_METHOD_FOUND,out = SeekMethod(line)
            if out is not "":
                fwrite.write ( out )

            BOOL_CLASS_FORWARD_DECL, out = SeekClassForwardDeclaration(line);
            if out is not "":
                fwrite.write ( out )

            if BOOL_METHOD_FOUND is False:
                BOOL_INSIDE_A_CLASS, out = CheckEndClass(line)
                if out is not "":
                     fwrite.write ( out )

                     if writelater is not "":
                        parentclassnamemocked = parentclassname+"_Mocked"
                        fwrite.write ("\n")
                        fwrite.write ("/* A singleton class to handle static methods of " + parentclassname + " */\n")
                        fwrite.write ("class "+parentclassnamemocked+" {\n")
                        fwrite.write ("    private:\n")
                        fwrite.write ("        "+parentclassnamemocked+"() {}\n")
                        fwrite.write ("        "+parentclassnamemocked+"(const "+ parentclassnamemocked+" &rhs);\n")
                        fwrite.write ("        "+parentclassnamemocked+" &operator=(const "+ parentclassnamemocked+" &rhs);\n")
                        fwrite.write ("    public:\n")
                        fwrite.write ("        "+parentclassnamemocked+"& get_impl(){\n")
                        fwrite.write ("            "+"static "+parentclassnamemocked+" oSingleton\n")
                        fwrite.write ("            return oSingleton\n")
                        fwrite.write ("        }\n")
                        fwrite.write ("\n")
                        fwrite.write ("        /*************************/\n")
                        fwrite.write ("        /* Mocked methods follow */\n")
                        fwrite.write ("        /*************************/\n")
                        fwrite.write (writelater)
                        fwrite.write ("};\n")
                        fwrite.write ("\n")
                        writelater = ""

        else:
            BOOL_INCLUSIONGUARD, out = SeekMultipleInclusionGuard(line);
            if out is not "":
                fwrite.write ( out )
            BOOL_DIRECTIVE, out = SeekBracket(line);
            if out is not "":
                fwrite.write ( out )
            if BOOL_INCLUSIONGUARD is False:
                BOOL_DIRECTIVE, out = SeekDirective(line);
                if out is not "":
                    fwrite.write ( out )
            #BOOL_INCLUDED, out = SeekInclude(line);
            #if out is not "":
            #    fwrite.write ( out )
            BOOL_INSIDE_A_CLASS, out = SeekClassDefinition(line);
            if out is not "":
                fwrite.write ( out )
            BOOL_INSIDE_A_STRUCT, out = SeekStructDefinition(line);
            if out is not "":
                fwrite.write ( out )
            BOOL_INSIDE_A_NAMESPACE, out = SeekNamespaceDefinition(line);
            if out is not "":
                fwrite.write ( out )
            BOOL_CLASS_FORWARD_DECL, out = SeekClassForwardDeclaration(line);
            if out is not "":
                fwrite.write ( out )




    #fwrite.write ( "#endif\n" )



    return

def SeekMultipleInclusionGuard(line):
    output = ""
    pattern = re.compile(r'^\s*(#ifndef|#define)\s+(.*(?:_HPP|_H))\s*$')
    match = pattern.match( line )
    if match is not None:
        output += match.group(1) + " " + "__MOCKED_" + match.group(2) + "__\n"

        if match.group(1) == "#define":
            output += "\n" 
            output += "/* Dependency on Google Mock: */\n"
            output += "#include \"gmock\\gmock.h\"\n"
            output += "\n"

        return True, output
    else:
        return False, output


def SeekBracket(line):
    output = ""
    pattern1 = re.compile(r'^\s*}(.*)$')
    pattern2 = re.compile(r'^\s*{(.*)$')
    match1 = pattern1.match( line )
    match2 = pattern2.match( line )

    if match1 is not None:
        output += "}" + match1.group(1) + "\n"
        return True, output;
    elif match2 is not None:
        output += "{" + match2.group(1) + "\n"
        return True, output;
    else:
        return False, output;


def SeekVariableDeclaration(line):
    output = ""
    pattern = re.compile(r'^\s*([\w:_]+)\s*(?:([*&]+)\s*){0,1}([\w\[\]]+)\s*;\s*$')
    match = pattern.match( line )
    if match is not None:
        STR_VARTYPE = match.group(1)
        if match.group(2) is not None:
            STR_VARTYPE = STR_VARTYPE + match.group(2)
        STR_VARNAME = match.group(3)

        output = "        " + STR_VARTYPE+ " " + STR_VARNAME +";\n"
        return True, output
    else:
        return False, output

def SeekClassForwardDeclaration(line):
    output = ""
    pattern = re.compile(r'^\s*((?:friend\s+){0,1}(?:class|struct))\s+([\w]+)\s*;\s*$')
    match = pattern.match( line )
    if match is not None:
        STR_CLASSTYPE = match.group(1)
        output += STR_CLASSTYPE;
        if match.group(2) is not None:
            STR_CLASSNAME = match.group(2)
            output += " "
            output += STR_CLASSNAME;
        output += ";"
        output += '\n'
        return True, output;
    else: 
        return False, output;

def SeekDirective(line):
    output = ""
    pattern = re.compile(r'^(#[\w]*)\s+(.*)$')
    match = pattern.match (line)
    if match is not None:
        output += match.group(1)
        output += ' '
        output += match.group(2)
        output += '\n'
        return (True, output)
    else:
        return (False, output)

def SeekStructDefinition(line):
    output = ""
    pattern = re.compile(r'^\s*(?:struct)\s+([\w]+)\s*(?::){0,1}((?:\s*(?:(?:public|protected|private)\s+){0,1}[\w:]??(?:\s*,){0,1})+)\s*(?:{){0,1}$')
    match = pattern.match( line )
    if match is not None:
        output += "struct "
        STR_CLASSNAME = match.group(1)
        output += STR_CLASSNAME;
        if match.group(2) is not None and match.group(2) is not "":
            STR_BASECLAUSE = match.group(2)
            output += ":"
            output += STR_BASECLAUSE;
        output += " {"
        output += '\n'
        return (True, output);
    else: 
        return (False, output);



def SeekInclude(line):
    output = ""
    pattern = re.compile(r'^\s*#include\s*(\"|<)(.+)(\"|>)\s*$')
    match = pattern.match( line )

    if match is not None:
        STR_INCLUDEDFILE = match.group(2)
        STR_OPENBRACKET = match.group(1)
        STR_CLOSEBRACKET = match.group(3)
        output += "#include" + " " + STR_OPENBRACKET + STR_INCLUDEDFILE + STR_CLOSEBRACKET
        output += '\n'
        return (True, output);
    else:
        return (False, output);

def SeekNamespaceDefinition( line ):
    output = ""
    pattern = re.compile(r'^\s*(?:namespace)\s+([\w:]+)\s*({){0,1}\s*$')
    match = pattern.match( line )
    if match is not None:
        output += "namespace "
        STR_NAMESPACENAME = match.group(1)
        output += STR_NAMESPACENAME
        if match.group(2) is not None:
            output += match.group(2)
        output += '\n'
        return True, output;
    else:
        return False, output;



def SeekClassDefinition(line):
#    pattern = re.compile(r'^\s*class\s*(\w*)')
    global parentclassname
    pattern = re.compile(r'^\s*(?:class)\s+([\w]+)\s*(?::){0,1}((?:\s*(?:(?:public|protected|private)\s+){0,1}[\w:]??(?:\s*,){0,1})+)\s*(?:{){0,1}$')
    match = pattern.match( line )
    output = ""
    if match is not None:
        output += "class "
        STR_CLASSNAME = match.group(1)
        parentclassname = STR_CLASSNAME
        output += STR_CLASSNAME;
        if ( match.group(2) is not None ) and (match.group(2) is not ""):
            STR_BASECLAUSE = match.group(2)
            output += ":"
            output += STR_BASECLAUSE;
        output += " {"
        output += '\n'
        output += '    public:\n'

        return (True, output);
    else: 
        return (False, output);

def SeekMethod(line):
    global writelater
    output = ""
    pattern =re.compile(r""+myexpressions.str_regexpattern_method_cppstaticmethod)
    match = pattern.match( line )
    if match is not None:
        if match.group(1) is not None:
            STR_STATICSPECIFIER = match.group(1)
        else:
            STR_STATICSPECIFIER = ''
        if match.group(2) is not None:
            STR_FUNCTIONSPECIFIER_FRONT = match.group(2)
        else:
            STR_FUNCTIONSPECIFIER_FRONT = ''
        if match.group(3) is not None:
            STR_RETURNTYPE = match.group(3)
        else:
            STR_RETURNTYPE = ''
        if match.group(4) is not None:
            STR_METHODNAME = match.group(4)
            STR_METHODNAME = STR_METHODNAME.strip()
        if match.group(5) is not None:
            STR_PARAMETERLIST =  match.group(5)
            if STR_PARAMETERLIST == "void":
                STR_PARAMETERLIST = ""
        if match.group(6) is not None:
            STR_INITIALIZERLIST = match.group(6)
        else:
            STR_INITIALIZERLIST = ''
        if match.group(7) is not None:
            STR_FUNCTIONSPECIFIER_BACK = match.group(7)
        else:
            STR_FUNCTIONSPECIFIER_BACK = ''

        output = "        "

        if STR_STATICSPECIFIER == 'static':
            print "Static Method found: " + match.group(0)
            output += STR_STATICSPECIFIER
            output += ' '
            output += STR_FUNCTIONSPECIFIER_FRONT
            output += STR_RETURNTYPE
            output += STR_METHODNAME
            output += '('
            output += STR_PARAMETERLIST
            output += ')'
            output += ' {\n'
            output += '\t\t\t'
            output += parentclassname
            output += '_Mocked'
            output += '::get_impl().'
            output += STR_METHODNAME
            output += '('
            output += STR_PARAMETERLIST
            output += ');'
            output += '\n'
            output += '\t\t}\n'

            writelater += "        "
            writelater += "MOCK_METHOD"

            ASTR_SPLITPARAMETERLIST = STR_PARAMETERLIST.split(',')
            number_of_params = len (ASTR_SPLITPARAMETERLIST)
            pattern2 =re.compile(r""+myexpressions.str_regexpattern_method_parameter)

            STR_ARRANGEDPARAMETERLIST = ""
            for i, STR_PARAMETER in enumerate(ASTR_SPLITPARAMETERLIST):
                match2 = pattern2.match( STR_PARAMETER )
                if match2 is not None:
                    if match2.group(1) is not None:
                        STR_ARRANGEDPARAMETERLIST += match2.group(1)
                    STR_ARRANGEDPARAMETERLIST += match2.group(2);
                    if match2.group(3) is not None:
                        STR_ARRANGEDPARAMETERLIST += match2.group(3);
                    STR_ARRANGEDPARAMETERLIST = STR_ARRANGEDPARAMETERLIST.strip()
                    if i != number_of_params - 1 :
                        STR_ARRANGEDPARAMETERLIST += ', '

            writelater += str(number_of_params)
            writelater += '('
            writelater += STR_METHODNAME
            writelater += ', '
            writelater += STR_RETURNTYPE
            writelater += '( '
            writelater += STR_ARRANGEDPARAMETERLIST
            writelater += ' ) );'
            writelater += '\n'

        else:

            if STR_RETURNTYPE == "":
                if STR_FUNCTIONSPECIFIER_FRONT != "":
                    output += STR_FUNCTIONSPECIFIER_FRONT + ' '
                #
                ASTR_SPLITPARAMETERLIST = STR_PARAMETERLIST.split(',')
                number_of_params = len (ASTR_SPLITPARAMETERLIST)

                pattern2 =re.compile(r""+myexpressions.str_regexpattern_method_parameter)

                STR_ARRANGEDPARAMETERLIST = ""
                for i, STR_PARAMETER in enumerate(ASTR_SPLITPARAMETERLIST):
                    match2 = pattern2.match( STR_PARAMETER )
                    if match2 is not None:
                        if match2.group(1) is not None:
                            STR_ARRANGEDPARAMETERLIST += match2.group(1)
                        STR_ARRANGEDPARAMETERLIST = STR_ARRANGEDPARAMETERLIST.strip()
                        STR_ARRANGEDPARAMETERLIST += match2.group(2);
                        STR_ARRANGEDPARAMETERLIST = STR_ARRANGEDPARAMETERLIST.strip()
                        if match2.group(3) is not None:
                            STR_ARRANGEDPARAMETERLIST += ' '
                            STR_ARRANGEDPARAMETERLIST += match2.group(3);
                        STR_ARRANGEDPARAMETERLIST = STR_ARRANGEDPARAMETERLIST.strip()
                        if i != number_of_params - 1 :
                            STR_ARRANGEDPARAMETERLIST += ', '
                #
                output += STR_METHODNAME + '(' + STR_ARRANGEDPARAMETERLIST + ')' 
                if STR_INITIALIZERLIST != "":
                    output += ':' + STR_INITIALIZERLIST
                if STR_FUNCTIONSPECIFIER_BACK != "":
                    output += ' ' + STR_FUNCTIONSPECIFIER_BACK
                output += ' { /* Stubbed to do nothing */ }\n'
            else:
                if 'const' in STR_FUNCTIONSPECIFIER_BACK:
                    output += "MOCK_CONST_METHOD"
                else:
                    output += "MOCK_METHOD"

                ASTR_SPLITPARAMETERLIST = STR_PARAMETERLIST.split(',')
                number_of_params = len (ASTR_SPLITPARAMETERLIST)

                pattern2 =re.compile(r""+myexpressions.str_regexpattern_method_parameter)

                STR_ARRANGEDPARAMETERLIST = ""
                for i, STR_PARAMETER in enumerate(ASTR_SPLITPARAMETERLIST):
                    match2 = pattern2.match( STR_PARAMETER )
                    if match2 is not None:
                        if match2.group(1) is not None:
                            STR_ARRANGEDPARAMETERLIST += match2.group(1)
                        STR_ARRANGEDPARAMETERLIST += match2.group(2);
                        if match2.group(3) is not None:
                            STR_ARRANGEDPARAMETERLIST += match2.group(3);
                        STR_ARRANGEDPARAMETERLIST = STR_ARRANGEDPARAMETERLIST.strip()
                        if i != number_of_params - 1 :
                            STR_ARRANGEDPARAMETERLIST += ', '

                output += str(number_of_params)
                output += '('
                output += STR_METHODNAME
                output += ', '
                output += STR_RETURNTYPE
                output += '( '
                output += STR_ARRANGEDPARAMETERLIST
                output += ' ) );'
                output += '\n'

        return True, output
    else:
        return False, output

def CheckEndClass(line):
    output = ""
    pattern = re.compile(r'^\s*?}\s*?([\w_]*?)\s*;\s*$')
    match = pattern.match( line )

    if match is not None:
        if match.group(1) is not None:
            output += '}' + match.group(1) + ';'
        else:
            output += '};' 

        output += '\n\n'
        return (False, output);
    else:
        return (True, output);

if __name__ == '__main__':
    main()





